const $ = (sel) => document.querySelector(sel);

const state = {
  data: null,
  status: "ALL",
  team: "ALL",
  sortBy: "UPDATED_DESC",
  apiNote: null
};

// ---------- Theme ----------
function loadTheme() {
  const saved = localStorage.getItem("hs_theme");
  const theme = saved || "light"; // light default
  document document.documentElement.setAttribute("data-theme", theme);
  updateThemeButton();
}

function toggleTheme() {
  const cur = document.documentElement.getAttribute("data-theme") || "light";
  const next = cur === "light" ? "dark" : "light";
  document.documentElement.setAttribute("data-theme", next);
  localStorage.setItem("hs_theme", next);
  updateThemeButton();
}

function updateThemeButton() {
  const cur = document.documentElement.getAttribute("data-theme") || "light";
  $("#themeToggle").textContent = cur === "light" ? "Dark" : "Light";
}

// ---------- Formatting ----------
function fmtRelative(iso) {
  const d = new Date(iso);
  if (isNaN(d.getTime())) return "—";
  const diffMs = Date.now() - d.getTime();
  const mins = Math.floor(diffMs / 60000);
  if (mins < 1) return "just now";
  if (mins < 60) return `${mins} min ago`;
  const hrs = Math.floor(mins / 60);
  if (hrs < 24) return `${hrs} hr ago`;
  const days = Math.floor(hrs / 24);
  return `${days} day${days === 1 ? "" : "s"} ago`;
}

function fmtUpdated(iso) {
  const d = new Date(iso);
  if (isNaN(d.getTime())) return "—";
  return d.toLocaleString(undefined, {
    month: "short",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit"
  });
}

function escapeHtml(s) {
  return String(s ?? "").replace(/[&<>"']/g, (c) => ({
    "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#039;"
  }[c]));
}

function badge(status) {
  const safe = String(status || "—").toUpperCase();
  return `
    <span class="badge status-${safe}">
      <span class="dot" aria-hidden="true"></span>
      <span>${safe}</span>
    </span>
  `;
}

// ---------- Sorting & Filtering ----------
function sortItems(items) {
  const copy = [...items];
  const by = state.sortBy;

  // ESPN-ish: status severity first if you choose STATUS_ASC
  const statusOrder = { OUT: 0, DOUBTFUL: 1, QUESTIONABLE: 2, PROBABLE: 3 };

  copy.sort((a, b) => {
    if (by === "UPDATED_DESC") return new Date(b.updated_iso) - new Date(a.updated_iso);
    if (by === "UPDATED_ASC") return new Date(a.updated_iso) - new Date(b.updated_iso);
    if (by === "PLAYER_ASC") return (a.player || "").localeCompare(b.player || "");
    if (by === "TEAM_ASC") return (a.team || "").localeCompare(b.team || "");
    if (by === "STATUS_ASC") return (statusOrder[a.status] ?? 99) - (statusOrder[b.status] ?? 99);
    return 0;
  });

  return copy;
}

function applyFilters(items) {
  return items.filter((it) => {
    const st = String(it.status || "").toUpperCase();
    const matchesStatus = state.status === "ALL" || st === state.status;
    const matchesTeam = state.team === "ALL" || it.team === state.team;
    return matchesStatus && matchesTeam;
  });
}

function groupByTeam(items) {
  const map = new Map();
  for (const it of items) {
    const t = it.team || "—";
    if (!map.has(t)) map.set(t, []);
    map.get(t).push(it);
  }
  return Array.from(map.entries()).sort((a, b) => a[0].localeCompare(b[0]));
}

// ---------- UI ----------
function populateTeamFilter(items) {
  const teams = Array.from(new Set(items.map((x) => x.team).filter(Boolean))).sort();
  const sel = $("#teamFilter");
  sel.querySelectorAll("option:not([value='ALL'])").forEach((o) => o.remove());

  for (const t of teams) {
    const opt = document.createElement("option");
    opt.value = t;
    opt.textContent = t;
    sel.appendChild(opt);
  }
}

function updateMeta(totalRows, filteredRows) {
  const lr = state.data?.last_refreshed_iso;

  $("#lastRefreshedPill").textContent =
    `Last refreshed: ${lr ? fmtUpdated(lr) : "—"} (${lr ? fmtRelative(lr) : "—"})`;

  $("#rowsPill").textContent = `Players: ${filteredRows} / ${totalRows}`;

  const noteEl = document.getElementById("apiNote");
  if (noteEl) {
    if (state.apiNote) {
      noteEl.textContent = state.apiNote;
      noteEl.hidden = false;
    } else {
      noteEl.hidden = true;
    }
  }
}

function renderEspnTable(rows) {
  const table = $("#injuriesByTeamTable");
  const tbody = table.querySelector("tbody");
  const emptyEl = $("#injuriesEmpty");

  tbody.innerHTML = "";

  if (!rows.length) {
    emptyEl.hidden = false;
    table.hidden = true;
    return;
  }

  emptyEl.hidden = true;
  table.hidden = false;

  const grouped = groupByTeam(rows);

  for (const [team, items] of grouped) {
    const trTeam = document.createElement("tr");
    trTeam.className = "teamRow";
    trTeam.innerHTML = `<td colspan="6">${escapeHtml(team)}</td>`;
    tbody.appendChild(trTeam);

    const sorted = sortItems(items);
    for (const it of sorted) {
      const tr = document.createElement("tr");
      tr.className = "playerRow";
      tr.innerHTML = `
        <td class="nameCell">
          <div class="playerName">${escapeHtml(it.player)}</div>
          <div class="injurySub">${escapeHtml(it.injury || "—")}</div>
        </td>
        <td class="colPos">${escapeHtml(it.pos || "—")}</td>
        <td class="colReturn">${escapeHtml(it.expected_return || "—")}</td>
        <td class="colStatus">${badge(it.status)}</td>
        <td class="commentCell">${escapeHtml(it.comment || "—")}</td>
        <td class="colUpdated" title="${escapeHtml(it.updated_iso)}">
          ${escapeHtml(fmtUpdated(it.updated_iso))}<br>
          <span class="muted">${escapeHtml(fmtRelative(it.updated_iso))}</span>
        </td>
      `;
      tbody.appendChild(tr);
    }
  }
}

// ---------- Data ----------
function normalizeIncoming(payload) {
  const items = Array.isArray(payload?.items) ? payload.items : [];

  const normalizedItems = items.map((it) => ({
    player: it.player ?? "Unknown",
    team: it.team ?? "—",
    pos: it.pos ?? it.position ?? "—",
    injury: it.injury ?? "—",
    status: String(it.status ?? "QUESTIONABLE").toUpperCase(),
    expected_return: it.expected_return ?? "—",
    updated_iso: it.updated_iso ?? new Date().toISOString(),
    comment: it.comment ?? "—"
  }));

  return {
    last_refreshed_iso: payload?.last_refreshed_iso ?? null,
    items: normalizedItems,
    note: payload?.note ?? null
  };
}

async function fetchInjuries() {
  // Production: your worker route
  try {
    const res = await fetch("/api/nba/injuries", { cache: "no-store" });
    if (!res.ok) throw new Error(`API error ${res.status}`);

    const payload = await res.json();
    const normalized = normalizeIncoming(payload);

    state.apiNote = normalized.note;
    state.data = normalized;
    populateTeamFilter(state.data.items || []);
    return;
  } catch (err) {
    // Local dev fallback
    const res2 = await fetch("./injuries.json", { cache: "no-store" });
    if (!res2.ok) {
      const text2 = await res2.text().catch(() => "");
      throw new Error(`Fallback failed ${res2.status}: ${text2.slice(0, 200)}`);
    }

    const payload2 = await res2.json();
    const normalized2 = normalizeIncoming(payload2);

    state.apiNote =
      normalized2.note ||
      "Local mode: loaded ./injuries.json (deploy /api/nba/injuries for auto-updates).";
    state.data = normalized2;

    populateTeamFilter(state.data.items || []);
  }
}

function render() {
  const all = state.data?.items || [];
  const filtered = applyFilters(all);
  renderEspnTable(filtered);
  updateMeta(all.length, filtered.length);
}

// ---------- Init ----------
async function init() {
  loadTheme();
  $("#themeToggle").addEventListener("click", toggleTheme);
  $("#year").textContent = String(new Date().getFullYear());

  $("#statusFilter").addEventListener("change", (e) => {
    state.status = e.target.value;
    render();
  });

  $("#teamFilter").addEventListener("change", (e) => {
    state.team = e.target.value;
    render();
  });

  await fetchInjuries();
  render();

  // Auto-refresh every 2 minutes
  setInterval(async () => {
    try {
      await fetchInjuries();
      render();
    } catch (e) {
      console.warn("Auto-refresh failed:", e);
    }
  }, 2 * 60 * 1000);
}

init().catch((err) => {
  console.error(err);
  alert(
    "Could not load injury data.\n\n" +
    "Local: ensure injuries.json is in the same folder and you are running a local server.\n" +
    "Deployed: ensure /api/nba/injuries is routed to your Worker."
  );
});
